<?php
/**
 * @file
 * Code for the CIS Section feature.
 */
 
define('CIS_SECTION_STUDENT', 'student');
define('CIS_SECTION_PAST_STUDENT', 'past student');

include_once 'cis_section.features.inc';

/**
 * Implements hook_page_build().
 */
function cis_section_page_build(&$page) {
  drupal_add_css(drupal_get_path('module', 'cis_section') . '/cis_section.css');
}

/**
 * Implements hook_cron().
 */
function cis_section_cron() {
  // the magic that keeps sections in sync with the cis
  if (module_exists('cis_connector')) {
    $query = array(
      'type' => 'course',
      'field_machine_name' => str_replace('/', '', base_path()),
      'deep-load-refs' => 'field_collection_item', // special property that tells sections from course
    );
    // return a course
    $return = _cis_connection_query($query, 'node', 'json', 'GET', 'cis', '', FALSE);
    // look for 1 record
    if (count($return['list']) == 1) {
      $section_strings = array();
      $course = $return['list'][0];
      // loop through offerings
      foreach ($course['field_offerings'] as $offering) {
        // loop through sections if they exist
        if (isset($offering['field_sections']['und']) && count($offering['field_sections']['und']) > 0) {
          foreach ($offering['field_sections']['und'] as $section) {
            // verify that this has the full object
            if (!isset($section['value'])) {
              // loop through access strings
              // this is the magic that binds students to sections automatically
              // and allows the entire network to work as an OG dark-net :)
              if (isset($section['field_access_string']['und']) && count($section['field_access_string']['und']) > 0) {
                foreach($section['field_access_string']['und'] as $string) {
                  $section_strings[$string['safe_value']] = $string['safe_value'];
                }
              }
            }
          }
        }
      }
      // loop through section strings to make sure we have a matching section node
      foreach ($section_strings as $section_id) {
        // if we don't know about this section, create it
        if (!_cis_section_load_section_by_id($section_id)) {
          $section = new stdClass();
          $section->type = 'section';
          node_object_prepare($section);
          // currently both items are given the section id
          $section->title = $section_id;
          $section->field_section_id['und'][0]['value'] = $section_id;
          // mark this as active so it can sync with systems
          $section->field_cis_active['und'][0]['value'] = 1;
          $section->language = LANGUAGE_NONE;
          // default these to admin ownership for less chance of seeing it
          $section->uid = 1;
          // save section, cron job will then be able to check data source for roster
          // if that functionality is enabled in local instance
          node_save($section);
        }
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function cis_section_node_insert($node) {
  // account for newly created sections being activated so we can react immediately
  if ($node->type == 'section' && $node->field_cis_active['und'][0]['value'] == 1) {
    cis_section_state_change($node, 'activate');
  }
}

/**
 * Implements hook_node_update().
 */
function cis_section_node_update($node) {
  // test for a section being deactivated
  if ($node->type == 'section') {
    if ($node->field_cis_active['und'][0]['value'] == 0) {
      cis_section_state_change($node, 'deactivate');
    }
    else {
      // allow other projects to perform actions based on this node being activated
      cis_section_state_change($node, 'activate');
    }
  }
}

/**
 * Implements hook_cis_section_deactivate().
 */
function cis_section_cis_section_deactivate() {
  return array('_cis_section_deactivate_section');
}

/**
 * Implements hook_cis_section_deactivate().
 */
function _cis_section_deactivate_section($node) {
  // standard conversion of student to past student roles
  $student = user_role_load_by_name(CIS_SECTION_STUDENT);
  $past = user_role_load_by_name(CIS_SECTION_PAST_STUDENT);
  $current = _cis_section_load_users_by_gid($node->nid, $student->rid);
  // find users that no longer came across
  $diff = array_diff($current, array());
  foreach ($diff as $uid) {
    $account = user_load($uid);
    // drop student role
    unset($account->roles[$student->rid]);
    // gain past student role
    $account->roles[$past->rid] = $past->name;
    user_save($account);
  }
}

/**
 * Load an organic group by unique section ID.
 */
function _cis_section_load_section_by_id($id) {
  // entity field query to load a section by id
  $query = new EntityFieldQuery();
  $query
  // pull group nodes
  ->entityCondition('entity_type', 'node')
  // of type section
  ->entityCondition('bundle', 'section')
  // that are published
  ->propertyCondition('status', 1)
  // only select based on the id we were passed
  ->fieldCondition('field_section_id', 'value', $id, '=')
  // execute this as user 1 to avoid object conflicts
  ->addMetaData('account', user_load(1))
  // only return 1 value
  ->range(0, 1);
  $result = $query->execute();
  // flip the results if it found them
  if (isset($result['node'])) {
    // we know there's only 1 value in this array
    return array_pop(array_keys($result['node']));
  }
  // no matches
  return FALSE;
}

/**
 * Load an organic group by unique section ID.
 */
function _cis_section_load_users_by_gid($gid, $rid = NULL) {
  // select from membership
  $query = db_select('og_membership', 'ogm');
  // only entity id
  $query->fields('ogm', array('etid'));
  // join user table
  $query->innerJoin('users', 'u', 'ogm.etid = u.uid');
  // join role table
  $query->innerJoin('users_roles', 'ur', 'u.uid = ur.uid');
  // where entity type is user
  $query->condition('ogm.entity_type', 'user');
  // and group is the one requested
  $query->condition('ogm.gid', $gid);
  // limit to a certain role if set
  if (!is_null($rid)) {
    $query->condition('ur.rid', $rid);
  }
  $result = $query->execute();
  // weird call but returns an array of the uids selected
  return array_keys($result->fetchAllAssoc('etid'));
}

/**
 * Run hooks for state of section.
 */
function cis_section_state_change($node, $state = 'activate') {
  // activate / deactivate only two allowed states at this time
  if (!in_array($state, array('activate', 'deactivate'))) {
    return FALSE;
  }
  // easier calls for activate / deactivate in bulk
  $calls = module_invoke_all('cis_section_' . $state);
  // alter the call list
  drupal_alter('cis_section_' . $state, $calls);
  // run each call
  foreach ($calls as $call) {
    call_user_func($call, $node);
  }
}

/**
 * Create accounts, groups, and associate to groups.
 */
function _cis_section_create_accounts($roster) {
  // loop through sections in the overall access roster
  foreach ($roster as $section => $members) {
    // loop through the user / role combination
    foreach ($members as $name => $role_name) {
      // convert role name to object bc of stupid storage convention for account creation
      $role = user_role_load_by_name($role_name);
      // try and load the account first
      if (!($account = user_load_by_name($name))) {
        $fields = array(
          'name' => $name,
          'pass' => user_password(20),
          'status' => 1,
          'init' => $email,
          'roles' => array(
            DRUPAL_AUTHENTICATED_RID => 'authenticated user',
            $role->rid => $role->name,
          ),
        );
        // allow other projects to update part of the user
        drupal_alter('cis_section_user_insert', $fields);
        //the first parameter is left blank so a new user is created
        $account = user_save('', $fields);
      }
      else {
        // only save role if it is new
        if (!isset($account->roles[$role->rid])) {
          $account->roles[$role->rid] = $role->name;
          user_save($account);
        }
      }
      // load group by section
      $gid = _cis_section_load_section_by_id($section);
      // false returned if this group doesn't exist
      if (!$gid) {
        // we need to create the group as this is a new one
        // this can happen if we get a group not created via LTI
        $group = new stdClass();
        $group->type = 'section';
        $group->status = 1;
        $group->uid = 1;
        $group->title = $section;
        $group->promote = 0;
        $group->revision = 1;
        $group->field_section_id = array(
          'und' => array(
            0 => array(
              'value' => $section,
            ),
          ),
        );
        node_save($group);
        $gid = $group->nid;
      }
      // add group membership
      $values = array(
        'entity_type' => 'user',
        'entity' => $account,
      );
      og_group('node', $gid, $values);
      // rip membership names to uid array for comparison
      $actual[] = $account->uid;
    }
    // compare members that just came across to members currently (that are students)
    // anyone currently that didn't just come across, gets role dropped
    // they gain past student
    $student = user_role_load_by_name(CIS_SECTION_STUDENT);
    $past = user_role_load_by_name(CIS_SECTION_PAST_STUDENT);
    $current = _cis_section_load_users_by_gid($gid, $student->rid);
    // find users that no longer came across
    $diff = array_diff($current, $actual);
    foreach ($diff as $uid) {
      $account = user_load($uid);
      // drop student role
      unset($account->roles[$student->rid]);
      // gain past student role
      $account->roles[$past->rid] = $past->name;
      user_save($account);
    }
  }
}