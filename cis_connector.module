<?php

/**
 * Build the registry of educational connectors
 */
function _cis_connector_build_registry($component = NULL) {
  // invoke special hook for registry settings
  $settings = module_invoke_all('cis_service_registry');
  // follows best practice of drupal but only provided for future override potential
  drupal_alter('cis_service_registry', $settings);
  if (!is_null($component)) {
    // validate that this component exists
    if (isset($settings[$component])) {
      return $settings[$component];
    }
    return FALSE;
  }
  // validate settings were found
  if (!empty($settings)) {
    return $settings;
  }
  return FALSE;
}

/**
 * Wrapper for structured calls against CIS system
 */
function _cis_connection_object($id = NULL, $entity_type = 'node', $format = 'json', $method = 'GET', $data = NULL, $bucket = 'cis', $instance = '', $extra = '', $call_options = NULL) {
  // invoke special hook for registry settings
  // options for method
  $options = array('method' => $method);
  if (!empty($call_options)) {
    $options += $call_options;
  }
  // allow for PUT requests which require use of the data property
  if (!empty($data)) {
    $options['data'] = json_encode($data);
    $options['headers'] = array('Content-Type' => 'application/json');
  }
  // build the call
  $call = $instance . $entity_type;
  if (!is_null($id)) {
   $call .= '/' . $id;
  }
  if (!empty($format)) {
    $call .= '.' . $format;
  }
  // allow for custom additions of properties like deep-load-refs
  if (!empty($extra)) {
    $call .= '?' . $extra;
  }
  
  $response = _cis_connector_request($call, $options, $bucket);
  // ensure a response to connect in the first place
  $data = FALSE;
  if ($response) {
    // parse format correctly for return if we can
    switch ($format) {
      case 'json':
        $data = json_decode($response->data, TRUE);
      break;
      case 'xml':
        $data = simplexml_load_string($response->data);
      break;
      default:
        $data = $response->data;
      break;
    }
  }
  return $data;
}

/**
 * Wrapper for structured updates to data in CIS.
 */
function _cis_connection_set_data($select, $data, $bucket, $instance) {
  // query to get an information set
  $resp = _cis_connection_query($select, 'node', 'json', 'GET', $bucket, $instance);
  // if we have an item, its a valid item
  if (!empty($resp['list'])) {
    // update all items that were found
    foreach ($resp['list'] as $response_item) {
      // special exception to account for body needing a format by name
      if (isset($data['body']) && !isset($data['body']['format'])) {
        $data['body']['format'] = $response_item['body']['format'];
      }
      // post back to CIS
      _cis_connection_object($response_item['nid'], 'node', NULL, 'PUT', $data, $bucket, $instance, '');
    }
  }
}

/**
 * Wrapper for structured queries against matching CIS services
 */
function _cis_connection_service_instance_query($bucket = 'cis', $entity_type = 'node', $query = array()) {
  // abstract a related sub-service, this will just remove the / if base-path is root
  $path = cis_connector_get_base();
  $result = _cis_connection_query($query, $entity_type, 'json', 'GET', $bucket, $path);
  // return items if any were found
  if (isset($result['list'])) {
    return $result['list'];
  }
  return NULL;
}

/**
 * Wrapper for structured queries against CIS system
 */
function _cis_connection_query($query = array(), $entity_type = 'node', $format = 'json', $method = 'GET', $bucket = 'cis', $instance = '') {
  // options for method
  $options = array('method' => $method);
  // build the call
  $call = $instance . $entity_type . '.' . $format . '?' . http_build_query($query);
  // generate the well structured request
  $response = _cis_connector_request($call, $options, $bucket);
  // ensure a response to connect in the first place
  $data = FALSE;
  if ($response) {
    // parse format correctly for return if we can
    switch ($format) {
      case 'json':
        $data = json_decode($response->data, TRUE);
      break;
      case 'xml':
        $data = simplexml_load_string($response->data);
      break;
      default:
        $data = $response->data;
      break;
    }
  }
  return $data;
}
/**
 * Return a well formed address based on certain values.
 */
function _cis_connector_format_address($settings, $instance = '') {
  // start with protocol
  $address = $settings['protocol'] . '://';
  // optional HTTP authenticated request, required in any *real* environment
  if (isset($settings['user'])) {
    $address .= $settings['user'] . ':' . $settings['pass'] . '@';
  }
  // append the connection address
  $address .= $settings['service_address'] . $instance;
  return $address;
}

/**
 * Swap file path from service_address to real file location
 */
function _cis_connector_real_address($path) {
  // verify settings bucket exist
  if ($settings = _cis_connector_build_registry('cis')) {
    // need to account for services in the services sites bucket
    // then need to swap service address for front-end address
    return str_replace('/services/', '/', str_replace($settings['service_address'], $settings['address'], $path));
  }
}

/**
 * Wrapper for http requests
 */  
function _cis_connector_request($url, $options = array(), $bucket = 'cis') {
  // allow for direct http requests
  if ($bucket == 'none') {
    // queue request
    httprl_request($url, $options);
    // send the request off
    $tmp = httprl_send_request();
    $data = array_pop($tmp);
  }
  // look for settings for this bucket
  else if ($settings = _cis_connector_build_registry($bucket)) {
    $address = _cis_connector_format_address($settings);
    // queue the request
    httprl_request($address . '/' . $url, $options);
    // send the request off
    $tmp = httprl_send_request();
    $data = array_pop($tmp);
  }
  else {
    drupal_set_message(t("Educational service registry call missing, connection unavailable. Please see README.txt for details on setup."), 'error');
    return FALSE;
  }
  // easiest way of debugging all calls
  /*if ($GLOBALS['user']->uid == 1) {
    dpm($data);
  }*/
  return $data;  
}

/**
 * Prepare an entity for transmission to a webservice
 * This primary involves "crushing" the item into an array
 */
function _cis_connection_prepare_entity($entity) {
  $ary = (array) $entity;
  foreach ($ary as $key => $val) {
    // make sure it's not a key value
    if (!in_array($key, array('uuid', 'promote', 'revision', 'status', 'sticky', 'body', 'title', 'type', 'language'))) {
      if (strpos($key, 'field_') !== 0) {
        unset($ary[$key]);
      }
      elseif (is_array($val)) {
        // TODO: support multiple field values
        if (isset($val[0]['value'])) {
          $ary[$key] = $val[0]['value'];
        }
        elseif (isset($val[0]['url'])) {
          $ary[$key] = $val[0];
        }
        else {
          // null case, remove it
          unset($ary[$key]);
        }
      }
    }
    elseif ($key == 'body') {
      $ary['body'] = array('value' => $val);
    }
  }
  return $ary;
}

/**
 * Return a base for connecting to a remote instance.
 */
function cis_connector_get_base() {
  $instance = base_path();
  drupal_alter('cis_connector_instance', $instance);
  return $instance;
}